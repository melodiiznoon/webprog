/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	var DTW = __webpack_require__(1);
	
	var nodeDTW = function() {
		// console.log(rgb);
		// var s = [1,1,2,3,2,0];
		// var t = [0,1,1,2,3,2,1];
		var normalArrayRGB = Array.prototype.slice.call(rgb);
		console.log(normalArrayRGB);
		var s = normalArrayRGB;
		var t = normalArrayRGB;
		var dtw = new DTW();
		var cost = dtw.compute(s, t);
		var path = dtw.path();
		console.log('Cost: ' + cost);
		console.log('Path: ');
		console.log(path);
	};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(2);


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @title DTW API
	 * @author Elmar Langholz
	 */
	
	var debug = __webpack_require__(3)('dtw');
	var validate = __webpack_require__(6);
	var matrix = __webpack_require__(7);
	var comparison = __webpack_require__(8);
	
	function validateOptions(options) {
	    if (typeof options !== 'object') {
	        throw new TypeError('Invalid options type: expected an object');
	    } else if (typeof options.distanceMetric !== 'string' && typeof options.distanceFunction !== 'function') {
	        throw new TypeError('Invalid distance types: expected a string distance type or a distance function');
	    } else if (typeof options.distanceMetric === 'string' && typeof options.distanceFunction === 'function') {
	        throw new Error('Invalid parameters: provide either a distance metric or function but not both');
	    }
	
	    if (typeof options.distanceMetric === 'string') {
	        var normalizedDistanceMetric = options.distanceMetric.toLowerCase();
	        if (normalizedDistanceMetric !== 'manhattan' && normalizedDistanceMetric !== 'euclidean'
	            && normalizedDistanceMetric !== 'squaredeuclidean') {
	            throw new Error('Invalid parameter value: Unknown distance metric \'' + options.distanceMetric + '\'');
	        }
	    }
	}
	
	function retrieveDistanceFunction(distanceMetric) {
	    var normalizedDistanceMetric = distanceMetric.toLowerCase();
	    var distanceFunction = null;
	    if (normalizedDistanceMetric === 'manhattan') {
	        distanceFunction = __webpack_require__(9).distance;
	    } else if (normalizedDistanceMetric === 'euclidean') {
	        distanceFunction = __webpack_require__(10).distance;
	    } else if (normalizedDistanceMetric === 'squaredeuclidean') {
	        distanceFunction = __webpack_require__(11).distance;
	    }
	
	    return distanceFunction;
	}
	
	/**
	 * Create a DTWOptions object
	 * @class DTWOptions
	 * @member {string} distanceMetric The distance metric to use: `'manhattan' | 'euclidean' | 'squaredEuclidean'`.
	 * @member {function} distanceFunction The distance function to use. The function should accept two numeric arguments and return the numeric distance. e.g. function (a, b) { return a + b; }
	 */
	
	/**
	 * Create a DTW object
	 * @class DTW
	 */
	/**
	 * Initializes a new instance of the `DTW`. If no options are provided the squared euclidean distance function is used.
	 * @function DTW
	 * @param {DTWOptions} [options] The options to initialize the dynamic time warping instance with.
	 */
	/**
	 * Computes the optimal match between two provided sequences.
	 * @method compute
	 * @param {number[]} firstSequence The first sequence.
	 * @param {number[]} secondSequence The second sequence.
	 * @param {number} [window] The window parameter (for the locality constraint) to use.
	 * @returns {number} The similarity between the provided temporal sequences.
	 */
	/**
	 * Retrieves the optimal match between two provided sequences.
	 * @method path
	 * @returns {number[]} The array containing the optimal path points.
	 */
	var DTW = function (options) {
	    var state = { distanceCostMatrix: null };
	    if (typeof options === 'undefined') {
	        state.distance = __webpack_require__(11).distance;
	    } else {
	        validateOptions(options);
	        if (typeof options.distanceMetric === 'string') {
	            state.distance = retrieveDistanceFunction(options.distanceMetric);
	        } else if (typeof options.distanceFunction === 'function') {
	            state.distance = options.distanceFunction;
	        }
	    }
	
	    this.compute = function (firstSequence, secondSequence, window) {
	        var cost = Number.POSITIVE_INFINITY;
	        if (typeof window === 'undefined') {
	            cost = computeOptimalPath(firstSequence, secondSequence, state);
	        } else if (typeof window === 'number') {
	            cost = computeOptimalPathWithWindow(firstSequence, secondSequence, window, state);
	        } else {
	            throw new TypeError('Invalid window parameter type: expected a number');
	        }
	
	        return cost;
	    };
	
	    this.path = function () {
	        var path = null;
	        if (state.distanceCostMatrix instanceof Array) {
	            path = retrieveOptimalPath(state);
	        }
	
	        return path;
	    };
	};
	
	function validateComputeParameters(s, t) {
	    validate.sequence(s, 'firstSequence');
	    validate.sequence(t, 'secondSequence');
	}
	
	function computeOptimalPath(s, t, state) {
	    debug('> computeOptimalPath');
	    validateComputeParameters(s, t);
	    var start = new Date().getTime();
	    state.m = s.length;
	    state.n = t.length;
	    var distanceCostMatrix = matrix.create(state.m, state.n, Number.POSITIVE_INFINITY);
	
	    distanceCostMatrix[0][0] = state.distance(s[0], t[0]);
	
	    for (var rowIndex = 1; rowIndex < state.m; rowIndex++) {
	        var cost = state.distance(s[rowIndex], t[0]);
	        distanceCostMatrix[rowIndex][0] = cost + distanceCostMatrix[rowIndex - 1][0];
	    }
	
	    for (var columnIndex = 1; columnIndex < state.n; columnIndex++) {
	        var cost = state.distance(s[0], t[columnIndex]);
	        distanceCostMatrix[0][columnIndex] = cost + distanceCostMatrix[0][columnIndex - 1];
	    }
	
	    for (var rowIndex = 1; rowIndex < state.m; rowIndex++) {
	        for (var columnIndex = 1; columnIndex < state.n; columnIndex++) {
	            var cost = state.distance(s[rowIndex], t[columnIndex]);
	            distanceCostMatrix[rowIndex][columnIndex] =
	                cost + Math.min(
	                    distanceCostMatrix[rowIndex - 1][columnIndex],          // Insertion
	                    distanceCostMatrix[rowIndex][columnIndex - 1],          // Deletion
	                    distanceCostMatrix[rowIndex - 1][columnIndex - 1]);     // Match
	        }
	    }
	
	    var end = new Date().getTime();
	    var time = end - start;
	    debug('< computeOptimalPath (' + time + ' ms)');
	    state.distanceCostMatrix = distanceCostMatrix;
	    state.similarity = distanceCostMatrix[state.m - 1][state.n - 1];
	    return state.similarity;
	}
	
	function computeOptimalPathWithWindow(s, t, w, state) {
	    debug('> computeOptimalPathWithWindow');
	    validateComputeParameters(s, t);
	    var start = new Date().getTime();
	    state.m = s.length;
	    state.n = t.length;
	    var window = Math.max(w, Math.abs(s.length - t.length));
	    var distanceCostMatrix = matrix.create(state.m + 1, state.n + 1, Number.POSITIVE_INFINITY);
	    distanceCostMatrix[0][0] = 0;
	
	    for (var rowIndex = 1; rowIndex <= state.m; rowIndex++) {
	        for (var columnIndex = Math.max(1, rowIndex - window); columnIndex <= Math.min(state.n, rowIndex + window); columnIndex++) {
	            var cost = state.distance(s[rowIndex - 1], t[columnIndex - 1]);
	            distanceCostMatrix[rowIndex][columnIndex] =
	                cost + Math.min(
	                distanceCostMatrix[rowIndex - 1][columnIndex],          // Insertion
	                distanceCostMatrix[rowIndex][columnIndex - 1],          // Deletion
	                distanceCostMatrix[rowIndex - 1][columnIndex - 1]);     // Match
	        }
	    }
	
	    var end = new Date().getTime();
	    var time = end - start;
	    debug('< computeOptimalPathWithWindow (' + time + ' ms)');
	    distanceCostMatrix.shift();
	    distanceCostMatrix = distanceCostMatrix.map(function (row) {
	        return row.slice(1, row.length);
	    });
	    state.distanceCostMatrix = distanceCostMatrix;
	    state.similarity = distanceCostMatrix[state.m - 1][state.n - 1];
	    return state.similarity;
	}
	
	function retrieveOptimalPath(state) {
	    debug('> retrieveOptimalPath');
	    var start = new Date().getTime();
	
	    var rowIndex = state.m - 1;
	    var columnIndex = state.n - 1;
	    var path = [[rowIndex, columnIndex]];
	    var epsilon = 1e-14;
	    while ((rowIndex > 0) || (columnIndex > 0)) {
	        if ((rowIndex > 0) && (columnIndex > 0)) {
	            var min = Math.min(
	                state.distanceCostMatrix[rowIndex - 1][columnIndex],          // Insertion
	                state.distanceCostMatrix[rowIndex][columnIndex - 1],          // Deletion
	                state.distanceCostMatrix[rowIndex - 1][columnIndex - 1]);     // Match
	            if (comparison.nearlyEqual(min, state.distanceCostMatrix[rowIndex - 1][columnIndex - 1], epsilon)) {
	                rowIndex--;
	                columnIndex--;
	            } else if (comparison.nearlyEqual(min, state.distanceCostMatrix[rowIndex - 1][columnIndex], epsilon)) {
	                rowIndex--;
	            } else if (comparison.nearlyEqual(min, state.distanceCostMatrix[rowIndex][columnIndex - 1], epsilon)) {
	                columnIndex--;
	            }
	        } else if ((rowIndex > 0) && (columnIndex === 0)) {
	            rowIndex--;
	        } else if ((rowIndex === 0) && (columnIndex > 0)) {
	            columnIndex--;
	        }
	
	        path.push([rowIndex, columnIndex]);
	    }
	
	    var end = new Date().getTime();
	    var time = end - start;
	    debug('< retrieveOptimalPath (' + time + ' ms)');
	    return path.reverse();
	}
	
	module.exports = DTW;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the web browser implementation of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = __webpack_require__(4);
	exports.log = log;
	exports.formatArgs = formatArgs;
	exports.save = save;
	exports.load = load;
	exports.useColors = useColors;
	exports.storage = 'undefined' != typeof chrome
	               && 'undefined' != typeof chrome.storage
	                  ? chrome.storage.local
	                  : localstorage();
	
	/**
	 * Colors.
	 */
	
	exports.colors = [
	  'lightseagreen',
	  'forestgreen',
	  'goldenrod',
	  'dodgerblue',
	  'darkorchid',
	  'crimson'
	];
	
	/**
	 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
	 * and the Firebug extension (any Firefox version) are known
	 * to support "%c" CSS customizations.
	 *
	 * TODO: add a `localStorage` variable to explicitly enable/disable colors
	 */
	
	function useColors() {
	  // is webkit? http://stackoverflow.com/a/16459606/376773
	  return ('WebkitAppearance' in document.documentElement.style) ||
	    // is firebug? http://stackoverflow.com/a/398120/376773
	    (window.console && (console.firebug || (console.exception && console.table))) ||
	    // is firefox >= v31?
	    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
	    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
	}
	
	/**
	 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
	 */
	
	exports.formatters.j = function(v) {
	  return JSON.stringify(v);
	};
	
	
	/**
	 * Colorize log arguments if enabled.
	 *
	 * @api public
	 */
	
	function formatArgs() {
	  var args = arguments;
	  var useColors = this.useColors;
	
	  args[0] = (useColors ? '%c' : '')
	    + this.namespace
	    + (useColors ? ' %c' : ' ')
	    + args[0]
	    + (useColors ? '%c ' : ' ')
	    + '+' + exports.humanize(this.diff);
	
	  if (!useColors) return args;
	
	  var c = 'color: ' + this.color;
	  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));
	
	  // the final "%c" is somewhat tricky, because there could be other
	  // arguments passed either before or after the %c, so we need to
	  // figure out the correct index to insert the CSS into
	  var index = 0;
	  var lastC = 0;
	  args[0].replace(/%[a-z%]/g, function(match) {
	    if ('%%' === match) return;
	    index++;
	    if ('%c' === match) {
	      // we only are interested in the *last* %c
	      // (the user may have provided their own)
	      lastC = index;
	    }
	  });
	
	  args.splice(lastC, 0, c);
	  return args;
	}
	
	/**
	 * Invokes `console.log()` when available.
	 * No-op when `console.log` is not a "function".
	 *
	 * @api public
	 */
	
	function log() {
	  // this hackery is required for IE8/9, where
	  // the `console.log` function doesn't have 'apply'
	  return 'object' === typeof console
	    && console.log
	    && Function.prototype.apply.call(console.log, console, arguments);
	}
	
	/**
	 * Save `namespaces`.
	 *
	 * @param {String} namespaces
	 * @api private
	 */
	
	function save(namespaces) {
	  try {
	    if (null == namespaces) {
	      exports.storage.removeItem('debug');
	    } else {
	      exports.storage.debug = namespaces;
	    }
	  } catch(e) {}
	}
	
	/**
	 * Load `namespaces`.
	 *
	 * @return {String} returns the previously persisted debug modes
	 * @api private
	 */
	
	function load() {
	  var r;
	  try {
	    r = exports.storage.debug;
	  } catch(e) {}
	  return r;
	}
	
	/**
	 * Enable namespaces listed in `localStorage.debug` initially.
	 */
	
	exports.enable(load());
	
	/**
	 * Localstorage attempts to return the localstorage.
	 *
	 * This is necessary because safari throws
	 * when a user disables cookies/localstorage
	 * and you attempt to access it.
	 *
	 * @return {LocalStorage}
	 * @api private
	 */
	
	function localstorage(){
	  try {
	    return window.localStorage;
	  } catch (e) {}
	}


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * This is the common logic for both the Node.js and web browser
	 * implementations of `debug()`.
	 *
	 * Expose `debug()` as the module.
	 */
	
	exports = module.exports = debug;
	exports.coerce = coerce;
	exports.disable = disable;
	exports.enable = enable;
	exports.enabled = enabled;
	exports.humanize = __webpack_require__(5);
	
	/**
	 * The currently active debug mode names, and names to skip.
	 */
	
	exports.names = [];
	exports.skips = [];
	
	/**
	 * Map of special "%n" handling functions, for the debug "format" argument.
	 *
	 * Valid key names are a single, lowercased letter, i.e. "n".
	 */
	
	exports.formatters = {};
	
	/**
	 * Previously assigned color.
	 */
	
	var prevColor = 0;
	
	/**
	 * Previous log timestamp.
	 */
	
	var prevTime;
	
	/**
	 * Select a color.
	 *
	 * @return {Number}
	 * @api private
	 */
	
	function selectColor() {
	  return exports.colors[prevColor++ % exports.colors.length];
	}
	
	/**
	 * Create a debugger with the given `namespace`.
	 *
	 * @param {String} namespace
	 * @return {Function}
	 * @api public
	 */
	
	function debug(namespace) {
	
	  // define the `disabled` version
	  function disabled() {
	  }
	  disabled.enabled = false;
	
	  // define the `enabled` version
	  function enabled() {
	
	    var self = enabled;
	
	    // set `diff` timestamp
	    var curr = +new Date();
	    var ms = curr - (prevTime || curr);
	    self.diff = ms;
	    self.prev = prevTime;
	    self.curr = curr;
	    prevTime = curr;
	
	    // add the `color` if not set
	    if (null == self.useColors) self.useColors = exports.useColors();
	    if (null == self.color && self.useColors) self.color = selectColor();
	
	    var args = Array.prototype.slice.call(arguments);
	
	    args[0] = exports.coerce(args[0]);
	
	    if ('string' !== typeof args[0]) {
	      // anything else let's inspect with %o
	      args = ['%o'].concat(args);
	    }
	
	    // apply any `formatters` transformations
	    var index = 0;
	    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
	      // if we encounter an escaped % then don't increase the array index
	      if (match === '%%') return match;
	      index++;
	      var formatter = exports.formatters[format];
	      if ('function' === typeof formatter) {
	        var val = args[index];
	        match = formatter.call(self, val);
	
	        // now we need to remove `args[index]` since it's inlined in the `format`
	        args.splice(index, 1);
	        index--;
	      }
	      return match;
	    });
	
	    if ('function' === typeof exports.formatArgs) {
	      args = exports.formatArgs.apply(self, args);
	    }
	    var logFn = enabled.log || exports.log || console.log.bind(console);
	    logFn.apply(self, args);
	  }
	  enabled.enabled = true;
	
	  var fn = exports.enabled(namespace) ? enabled : disabled;
	
	  fn.namespace = namespace;
	
	  return fn;
	}
	
	/**
	 * Enables a debug mode by namespaces. This can include modes
	 * separated by a colon and wildcards.
	 *
	 * @param {String} namespaces
	 * @api public
	 */
	
	function enable(namespaces) {
	  exports.save(namespaces);
	
	  var split = (namespaces || '').split(/[\s,]+/);
	  var len = split.length;
	
	  for (var i = 0; i < len; i++) {
	    if (!split[i]) continue; // ignore empty strings
	    namespaces = split[i].replace(/\*/g, '.*?');
	    if (namespaces[0] === '-') {
	      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
	    } else {
	      exports.names.push(new RegExp('^' + namespaces + '$'));
	    }
	  }
	}
	
	/**
	 * Disable debug output.
	 *
	 * @api public
	 */
	
	function disable() {
	  exports.enable('');
	}
	
	/**
	 * Returns true if the given mode name is enabled, false otherwise.
	 *
	 * @param {String} name
	 * @return {Boolean}
	 * @api public
	 */
	
	function enabled(name) {
	  var i, len;
	  for (i = 0, len = exports.skips.length; i < len; i++) {
	    if (exports.skips[i].test(name)) {
	      return false;
	    }
	  }
	  for (i = 0, len = exports.names.length; i < len; i++) {
	    if (exports.names[i].test(name)) {
	      return true;
	    }
	  }
	  return false;
	}
	
	/**
	 * Coerce `val`.
	 *
	 * @param {Mixed} val
	 * @return {Mixed}
	 * @api private
	 */
	
	function coerce(val) {
	  if (val instanceof Error) return val.stack || val.message;
	  return val;
	}


/***/ },
/* 5 */
/***/ function(module, exports) {

	/**
	 * Helpers.
	 */
	
	var s = 1000;
	var m = s * 60;
	var h = m * 60;
	var d = h * 24;
	var y = d * 365.25;
	
	/**
	 * Parse or format the given `val`.
	 *
	 * Options:
	 *
	 *  - `long` verbose formatting [false]
	 *
	 * @param {String|Number} val
	 * @param {Object} options
	 * @return {String|Number}
	 * @api public
	 */
	
	module.exports = function(val, options){
	  options = options || {};
	  if ('string' == typeof val) return parse(val);
	  return options.long
	    ? long(val)
	    : short(val);
	};
	
	/**
	 * Parse the given `str` and return milliseconds.
	 *
	 * @param {String} str
	 * @return {Number}
	 * @api private
	 */
	
	function parse(str) {
	  str = '' + str;
	  if (str.length > 10000) return;
	  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
	  if (!match) return;
	  var n = parseFloat(match[1]);
	  var type = (match[2] || 'ms').toLowerCase();
	  switch (type) {
	    case 'years':
	    case 'year':
	    case 'yrs':
	    case 'yr':
	    case 'y':
	      return n * y;
	    case 'days':
	    case 'day':
	    case 'd':
	      return n * d;
	    case 'hours':
	    case 'hour':
	    case 'hrs':
	    case 'hr':
	    case 'h':
	      return n * h;
	    case 'minutes':
	    case 'minute':
	    case 'mins':
	    case 'min':
	    case 'm':
	      return n * m;
	    case 'seconds':
	    case 'second':
	    case 'secs':
	    case 'sec':
	    case 's':
	      return n * s;
	    case 'milliseconds':
	    case 'millisecond':
	    case 'msecs':
	    case 'msec':
	    case 'ms':
	      return n;
	  }
	}
	
	/**
	 * Short format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function short(ms) {
	  if (ms >= d) return Math.round(ms / d) + 'd';
	  if (ms >= h) return Math.round(ms / h) + 'h';
	  if (ms >= m) return Math.round(ms / m) + 'm';
	  if (ms >= s) return Math.round(ms / s) + 's';
	  return ms + 'ms';
	}
	
	/**
	 * Long format for `ms`.
	 *
	 * @param {Number} ms
	 * @return {String}
	 * @api private
	 */
	
	function long(ms) {
	  return plural(ms, d, 'day')
	    || plural(ms, h, 'hour')
	    || plural(ms, m, 'minute')
	    || plural(ms, s, 'second')
	    || ms + ' ms';
	}
	
	/**
	 * Pluralization helper.
	 */
	
	function plural(ms, n, name) {
	  if (ms < n) return;
	  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
	  return Math.ceil(ms / n) + ' ' + name + 's';
	}


/***/ },
/* 6 */
/***/ function(module, exports) {

	function validateSequence(sequence, sequenceParameterName) {
	    if (!(sequence instanceof Array)) {
	        throw new TypeError('Invalid sequence \'' + sequenceParameterName + '\' type: expected an array');
	    }
	
	    if (sequence.length < 1) {
	        throw new Error('Invalid number of sequence data points for \'' + sequenceParameterName + '\': expected at least one');
	    }
	
	    if (typeof sequence[0] !== 'number') {
	        throw new TypeError('Invalid data points types for sequence \'' + sequenceParameterName + '\': expected a number');
	    }
	}
	
	module.exports = {
	    sequence: validateSequence
	};


/***/ },
/* 7 */
/***/ function(module, exports) {

	var createArray = function (length, value) {
	    if (typeof length !== 'number') {
	        throw new TypeError('Invalid length type');
	    }
	
	    if (typeof value === 'undefined') {
	        throw new Error('Invalid value: expected a value to be provided');
	    }
	
	    var array = new Array(length);
	    for (var index = 0; index < length; index++) {
	        array[index] = value;
	    }
	
	    return array;
	};
	
	var createMatrix = function (m, n, value) {
	    var matrix = [];
	    for (var rowIndex = 0; rowIndex < m; rowIndex++) {
	        matrix.push(createArray(n, value));
	    }
	
	    return matrix;
	};
	
	module.exports = {
	    create: createMatrix
	};


/***/ },
/* 8 */
/***/ function(module, exports) {

	var EPSILON = 2.2204460492503130808472633361816E-16;
	
	var nearlyEqual = function (i, j, epsilon) {
	    var iAbsolute= Math.abs(i);
	    var jAbsolute = Math.abs(j);
	    var difference = Math.abs(i - j);
	    var equal = i === j;
	    if (!equal) {
	        equal = difference < EPSILON;
	        if (!equal) {
	            equal = difference <= Math.max(iAbsolute, jAbsolute) * epsilon;
	        }
	    }
	
	    return equal;
	};
	
	module.exports = {
	    EPSILON: EPSILON,
	    nearlyEqual: nearlyEqual
	};

/***/ },
/* 9 */
/***/ function(module, exports) {

	var distance = function (x, y) {
	    var difference = x - y;
	    var manhattanDistance = Math.abs(difference);
	    return manhattanDistance;
	};
	
	module.exports = {
	    distance: distance
	};


/***/ },
/* 10 */
/***/ function(module, exports) {

	var distance = function (x, y) {
	    var difference = x - y;
	    var euclideanDistance = Math.sqrt(difference * difference);
	    return euclideanDistance;
	};
	
	module.exports = {
	    distance: distance
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	var distance = function (x, y) {
	    var difference = x - y;
	    var squaredEuclideanDistance = difference * difference;
	    return squaredEuclideanDistance;
	};
	
	module.exports = {
	    distance: distance
	};


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYzA0NmYxMWE3YzIxMmYxMjNjMWYiLCJ3ZWJwYWNrOi8vLy4vc2NyaXB0cy5qcyIsIndlYnBhY2s6Ly8vLi9+L2R0dy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L2R0dy9saWIvZHR3LmpzIiwid2VicGFjazovLy8uL34vZGVidWcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L2RlYnVnL2RlYnVnLmpzIiwid2VicGFjazovLy8uL34vbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kdHcvbGliL3ZhbGlkYXRlLmpzIiwid2VicGFjazovLy8uL34vZHR3L2xpYi9tYXRyaXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9kdHcvbGliL2NvbXBhcmlzb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9kdHcvbGliL2Rpc3RhbmNlRnVuY3Rpb25zL21hbmhhdHRhbi5qcyIsIndlYnBhY2s6Ly8vLi9+L2R0dy9saWIvZGlzdGFuY2VGdW5jdGlvbnMvZXVjbGlkZWFuLmpzIiwid2VicGFjazovLy8uL34vZHR3L2xpYi9kaXN0YW5jZUZ1bmN0aW9ucy9zcXVhcmVkRXVjbGlkZWFuLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUNoQkE7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVksT0FBTztBQUNuQixhQUFZLFNBQVMsd0pBQXdKLGNBQWM7QUFDM0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLFNBQVM7QUFDcEIsWUFBVyxTQUFTO0FBQ3BCLFlBQVcsT0FBTztBQUNsQixjQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGtCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDJCQUEwQixvQkFBb0I7QUFDOUM7QUFDQTtBQUNBOztBQUVBLDhCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixvQkFBb0I7QUFDOUMsa0NBQWlDLHVCQUF1QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXVFO0FBQ3ZFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEwQixxQkFBcUI7QUFDL0MsK0RBQThELHFEQUFxRDtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW1FO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0EsY0FBYTtBQUNiO0FBQ0EsY0FBYTtBQUNiO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQSxVQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7O0FDNU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBWSxPQUFPO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7Ozs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBaUIsU0FBUztBQUMxQiw2QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcE1BO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxjQUFjO0FBQ3pCLFlBQVcsT0FBTztBQUNsQixhQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE9BQU87QUFDbEIsYUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLGFBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXVCLGdCQUFnQjtBQUN2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDJCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7QUM1QkE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEc7Ozs7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoic2NyaXB0cy5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svYm9vdHN0cmFwIGMwNDZmMTFhN2MyMTJmMTIzYzFmXG4gKiovIiwidmFyIERUVyA9IHJlcXVpcmUoJ2R0dycpO1xuXG52YXIgbm9kZURUVyA9IGZ1bmN0aW9uKCkge1xuXHQvLyBjb25zb2xlLmxvZyhyZ2IpO1xuXHQvLyB2YXIgcyA9IFsxLDEsMiwzLDIsMF07XG5cdC8vIHZhciB0ID0gWzAsMSwxLDIsMywyLDFdO1xuXHR2YXIgbm9ybWFsQXJyYXlSR0IgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChyZ2IpO1xuXHRjb25zb2xlLmxvZyhub3JtYWxBcnJheVJHQik7XG5cdHZhciBzID0gbm9ybWFsQXJyYXlSR0I7XG5cdHZhciB0ID0gbm9ybWFsQXJyYXlSR0I7XG5cdHZhciBkdHcgPSBuZXcgRFRXKCk7XG5cdHZhciBjb3N0ID0gZHR3LmNvbXB1dGUocywgdCk7XG5cdHZhciBwYXRoID0gZHR3LnBhdGgoKTtcblx0Y29uc29sZS5sb2coJ0Nvc3Q6ICcgKyBjb3N0KTtcblx0Y29uc29sZS5sb2coJ1BhdGg6ICcpO1xuXHRjb25zb2xlLmxvZyhwYXRoKTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NjcmlwdHMuanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2R0dycpO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kdHcvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcclxuICogQHRpdGxlIERUVyBBUElcclxuICogQGF1dGhvciBFbG1hciBMYW5naG9selxyXG4gKi9cclxuXHJcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2R0dycpO1xyXG52YXIgdmFsaWRhdGUgPSByZXF1aXJlKCcuL3ZhbGlkYXRlJyk7XHJcbnZhciBtYXRyaXggPSByZXF1aXJlKCcuL21hdHJpeCcpO1xyXG52YXIgY29tcGFyaXNvbiA9IHJlcXVpcmUoJy4vY29tcGFyaXNvbicpO1xyXG5cclxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wdGlvbnMgdHlwZTogZXhwZWN0ZWQgYW4gb2JqZWN0Jyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmRpc3RhbmNlTWV0cmljICE9PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0aW9ucy5kaXN0YW5jZUZ1bmN0aW9uICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBkaXN0YW5jZSB0eXBlczogZXhwZWN0ZWQgYSBzdHJpbmcgZGlzdGFuY2UgdHlwZSBvciBhIGRpc3RhbmNlIGZ1bmN0aW9uJyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmRpc3RhbmNlTWV0cmljID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygb3B0aW9ucy5kaXN0YW5jZUZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcnM6IHByb3ZpZGUgZWl0aGVyIGEgZGlzdGFuY2UgbWV0cmljIG9yIGZ1bmN0aW9uIGJ1dCBub3QgYm90aCcpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kaXN0YW5jZU1ldHJpYyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB2YXIgbm9ybWFsaXplZERpc3RhbmNlTWV0cmljID0gb3B0aW9ucy5kaXN0YW5jZU1ldHJpYy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmIChub3JtYWxpemVkRGlzdGFuY2VNZXRyaWMgIT09ICdtYW5oYXR0YW4nICYmIG5vcm1hbGl6ZWREaXN0YW5jZU1ldHJpYyAhPT0gJ2V1Y2xpZGVhbidcclxuICAgICAgICAgICAgJiYgbm9ybWFsaXplZERpc3RhbmNlTWV0cmljICE9PSAnc3F1YXJlZGV1Y2xpZGVhbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciB2YWx1ZTogVW5rbm93biBkaXN0YW5jZSBtZXRyaWMgXFwnJyArIG9wdGlvbnMuZGlzdGFuY2VNZXRyaWMgKyAnXFwnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiByZXRyaWV2ZURpc3RhbmNlRnVuY3Rpb24oZGlzdGFuY2VNZXRyaWMpIHtcclxuICAgIHZhciBub3JtYWxpemVkRGlzdGFuY2VNZXRyaWMgPSBkaXN0YW5jZU1ldHJpYy50b0xvd2VyQ2FzZSgpO1xyXG4gICAgdmFyIGRpc3RhbmNlRnVuY3Rpb24gPSBudWxsO1xyXG4gICAgaWYgKG5vcm1hbGl6ZWREaXN0YW5jZU1ldHJpYyA9PT0gJ21hbmhhdHRhbicpIHtcclxuICAgICAgICBkaXN0YW5jZUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9kaXN0YW5jZUZ1bmN0aW9ucy9tYW5oYXR0YW4nKS5kaXN0YW5jZTtcclxuICAgIH0gZWxzZSBpZiAobm9ybWFsaXplZERpc3RhbmNlTWV0cmljID09PSAnZXVjbGlkZWFuJykge1xyXG4gICAgICAgIGRpc3RhbmNlRnVuY3Rpb24gPSByZXF1aXJlKCcuL2Rpc3RhbmNlRnVuY3Rpb25zL2V1Y2xpZGVhbicpLmRpc3RhbmNlO1xyXG4gICAgfSBlbHNlIGlmIChub3JtYWxpemVkRGlzdGFuY2VNZXRyaWMgPT09ICdzcXVhcmVkZXVjbGlkZWFuJykge1xyXG4gICAgICAgIGRpc3RhbmNlRnVuY3Rpb24gPSByZXF1aXJlKCcuL2Rpc3RhbmNlRnVuY3Rpb25zL3NxdWFyZWRFdWNsaWRlYW4nKS5kaXN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZGlzdGFuY2VGdW5jdGlvbjtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIERUV09wdGlvbnMgb2JqZWN0XHJcbiAqIEBjbGFzcyBEVFdPcHRpb25zXHJcbiAqIEBtZW1iZXIge3N0cmluZ30gZGlzdGFuY2VNZXRyaWMgVGhlIGRpc3RhbmNlIG1ldHJpYyB0byB1c2U6IGAnbWFuaGF0dGFuJyB8ICdldWNsaWRlYW4nIHwgJ3NxdWFyZWRFdWNsaWRlYW4nYC5cclxuICogQG1lbWJlciB7ZnVuY3Rpb259IGRpc3RhbmNlRnVuY3Rpb24gVGhlIGRpc3RhbmNlIGZ1bmN0aW9uIHRvIHVzZS4gVGhlIGZ1bmN0aW9uIHNob3VsZCBhY2NlcHQgdHdvIG51bWVyaWMgYXJndW1lbnRzIGFuZCByZXR1cm4gdGhlIG51bWVyaWMgZGlzdGFuY2UuIGUuZy4gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgKyBiOyB9XHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIERUVyBvYmplY3RcclxuICogQGNsYXNzIERUV1xyXG4gKi9cclxuLyoqXHJcbiAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgRFRXYC4gSWYgbm8gb3B0aW9ucyBhcmUgcHJvdmlkZWQgdGhlIHNxdWFyZWQgZXVjbGlkZWFuIGRpc3RhbmNlIGZ1bmN0aW9uIGlzIHVzZWQuXHJcbiAqIEBmdW5jdGlvbiBEVFdcclxuICogQHBhcmFtIHtEVFdPcHRpb25zfSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgZHluYW1pYyB0aW1lIHdhcnBpbmcgaW5zdGFuY2Ugd2l0aC5cclxuICovXHJcbi8qKlxyXG4gKiBDb21wdXRlcyB0aGUgb3B0aW1hbCBtYXRjaCBiZXR3ZWVuIHR3byBwcm92aWRlZCBzZXF1ZW5jZXMuXHJcbiAqIEBtZXRob2QgY29tcHV0ZVxyXG4gKiBAcGFyYW0ge251bWJlcltdfSBmaXJzdFNlcXVlbmNlIFRoZSBmaXJzdCBzZXF1ZW5jZS5cclxuICogQHBhcmFtIHtudW1iZXJbXX0gc2Vjb25kU2VxdWVuY2UgVGhlIHNlY29uZCBzZXF1ZW5jZS5cclxuICogQHBhcmFtIHtudW1iZXJ9IFt3aW5kb3ddIFRoZSB3aW5kb3cgcGFyYW1ldGVyIChmb3IgdGhlIGxvY2FsaXR5IGNvbnN0cmFpbnQpIHRvIHVzZS5cclxuICogQHJldHVybnMge251bWJlcn0gVGhlIHNpbWlsYXJpdHkgYmV0d2VlbiB0aGUgcHJvdmlkZWQgdGVtcG9yYWwgc2VxdWVuY2VzLlxyXG4gKi9cclxuLyoqXHJcbiAqIFJldHJpZXZlcyB0aGUgb3B0aW1hbCBtYXRjaCBiZXR3ZWVuIHR3byBwcm92aWRlZCBzZXF1ZW5jZXMuXHJcbiAqIEBtZXRob2QgcGF0aFxyXG4gKiBAcmV0dXJucyB7bnVtYmVyW119IFRoZSBhcnJheSBjb250YWluaW5nIHRoZSBvcHRpbWFsIHBhdGggcG9pbnRzLlxyXG4gKi9cclxudmFyIERUVyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgc3RhdGUgPSB7IGRpc3RhbmNlQ29zdE1hdHJpeDogbnVsbCB9O1xyXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHN0YXRlLmRpc3RhbmNlID0gcmVxdWlyZSgnLi9kaXN0YW5jZUZ1bmN0aW9ucy9zcXVhcmVkRXVjbGlkZWFuJykuZGlzdGFuY2U7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGlzdGFuY2VNZXRyaWMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmRpc3RhbmNlID0gcmV0cmlldmVEaXN0YW5jZUZ1bmN0aW9uKG9wdGlvbnMuZGlzdGFuY2VNZXRyaWMpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuZGlzdGFuY2VGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBzdGF0ZS5kaXN0YW5jZSA9IG9wdGlvbnMuZGlzdGFuY2VGdW5jdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5jb21wdXRlID0gZnVuY3Rpb24gKGZpcnN0U2VxdWVuY2UsIHNlY29uZFNlcXVlbmNlLCB3aW5kb3cpIHtcclxuICAgICAgICB2YXIgY29zdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgY29zdCA9IGNvbXB1dGVPcHRpbWFsUGF0aChmaXJzdFNlcXVlbmNlLCBzZWNvbmRTZXF1ZW5jZSwgc3RhdGUpO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgY29zdCA9IGNvbXB1dGVPcHRpbWFsUGF0aFdpdGhXaW5kb3coZmlyc3RTZXF1ZW5jZSwgc2Vjb25kU2VxdWVuY2UsIHdpbmRvdywgc3RhdGUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgd2luZG93IHBhcmFtZXRlciB0eXBlOiBleHBlY3RlZCBhIG51bWJlcicpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGNvc3Q7XHJcbiAgICB9O1xyXG5cclxuICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcGF0aCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHN0YXRlLmRpc3RhbmNlQ29zdE1hdHJpeCBpbnN0YW5jZW9mIEFycmF5KSB7XHJcbiAgICAgICAgICAgIHBhdGggPSByZXRyaWV2ZU9wdGltYWxQYXRoKHN0YXRlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXRoO1xyXG4gICAgfTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29tcHV0ZVBhcmFtZXRlcnMocywgdCkge1xyXG4gICAgdmFsaWRhdGUuc2VxdWVuY2UocywgJ2ZpcnN0U2VxdWVuY2UnKTtcclxuICAgIHZhbGlkYXRlLnNlcXVlbmNlKHQsICdzZWNvbmRTZXF1ZW5jZScpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjb21wdXRlT3B0aW1hbFBhdGgocywgdCwgc3RhdGUpIHtcclxuICAgIGRlYnVnKCc+IGNvbXB1dGVPcHRpbWFsUGF0aCcpO1xyXG4gICAgdmFsaWRhdGVDb21wdXRlUGFyYW1ldGVycyhzLCB0KTtcclxuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgc3RhdGUubSA9IHMubGVuZ3RoO1xyXG4gICAgc3RhdGUubiA9IHQubGVuZ3RoO1xyXG4gICAgdmFyIGRpc3RhbmNlQ29zdE1hdHJpeCA9IG1hdHJpeC5jcmVhdGUoc3RhdGUubSwgc3RhdGUubiwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuXHJcbiAgICBkaXN0YW5jZUNvc3RNYXRyaXhbMF1bMF0gPSBzdGF0ZS5kaXN0YW5jZShzWzBdLCB0WzBdKTtcclxuXHJcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDE7IHJvd0luZGV4IDwgc3RhdGUubTsgcm93SW5kZXgrKykge1xyXG4gICAgICAgIHZhciBjb3N0ID0gc3RhdGUuZGlzdGFuY2Uoc1tyb3dJbmRleF0sIHRbMF0pO1xyXG4gICAgICAgIGRpc3RhbmNlQ29zdE1hdHJpeFtyb3dJbmRleF1bMF0gPSBjb3N0ICsgZGlzdGFuY2VDb3N0TWF0cml4W3Jvd0luZGV4IC0gMV1bMF07XHJcbiAgICB9XHJcblxyXG4gICAgZm9yICh2YXIgY29sdW1uSW5kZXggPSAxOyBjb2x1bW5JbmRleCA8IHN0YXRlLm47IGNvbHVtbkluZGV4KyspIHtcclxuICAgICAgICB2YXIgY29zdCA9IHN0YXRlLmRpc3RhbmNlKHNbMF0sIHRbY29sdW1uSW5kZXhdKTtcclxuICAgICAgICBkaXN0YW5jZUNvc3RNYXRyaXhbMF1bY29sdW1uSW5kZXhdID0gY29zdCArIGRpc3RhbmNlQ29zdE1hdHJpeFswXVtjb2x1bW5JbmRleCAtIDFdO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAodmFyIHJvd0luZGV4ID0gMTsgcm93SW5kZXggPCBzdGF0ZS5tOyByb3dJbmRleCsrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY29sdW1uSW5kZXggPSAxOyBjb2x1bW5JbmRleCA8IHN0YXRlLm47IGNvbHVtbkluZGV4KyspIHtcclxuICAgICAgICAgICAgdmFyIGNvc3QgPSBzdGF0ZS5kaXN0YW5jZShzW3Jvd0luZGV4XSwgdFtjb2x1bW5JbmRleF0pO1xyXG4gICAgICAgICAgICBkaXN0YW5jZUNvc3RNYXRyaXhbcm93SW5kZXhdW2NvbHVtbkluZGV4XSA9XHJcbiAgICAgICAgICAgICAgICBjb3N0ICsgTWF0aC5taW4oXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VDb3N0TWF0cml4W3Jvd0luZGV4IC0gMV1bY29sdW1uSW5kZXhdLCAgICAgICAgICAvLyBJbnNlcnRpb25cclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZUNvc3RNYXRyaXhbcm93SW5kZXhdW2NvbHVtbkluZGV4IC0gMV0sICAgICAgICAgIC8vIERlbGV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VDb3N0TWF0cml4W3Jvd0luZGV4IC0gMV1bY29sdW1uSW5kZXggLSAxXSk7ICAgICAvLyBNYXRjaFxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICB2YXIgZW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcbiAgICB2YXIgdGltZSA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgZGVidWcoJzwgY29tcHV0ZU9wdGltYWxQYXRoICgnICsgdGltZSArICcgbXMpJyk7XHJcbiAgICBzdGF0ZS5kaXN0YW5jZUNvc3RNYXRyaXggPSBkaXN0YW5jZUNvc3RNYXRyaXg7XHJcbiAgICBzdGF0ZS5zaW1pbGFyaXR5ID0gZGlzdGFuY2VDb3N0TWF0cml4W3N0YXRlLm0gLSAxXVtzdGF0ZS5uIC0gMV07XHJcbiAgICByZXR1cm4gc3RhdGUuc2ltaWxhcml0eTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcHV0ZU9wdGltYWxQYXRoV2l0aFdpbmRvdyhzLCB0LCB3LCBzdGF0ZSkge1xyXG4gICAgZGVidWcoJz4gY29tcHV0ZU9wdGltYWxQYXRoV2l0aFdpbmRvdycpO1xyXG4gICAgdmFsaWRhdGVDb21wdXRlUGFyYW1ldGVycyhzLCB0KTtcclxuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgc3RhdGUubSA9IHMubGVuZ3RoO1xyXG4gICAgc3RhdGUubiA9IHQubGVuZ3RoO1xyXG4gICAgdmFyIHdpbmRvdyA9IE1hdGgubWF4KHcsIE1hdGguYWJzKHMubGVuZ3RoIC0gdC5sZW5ndGgpKTtcclxuICAgIHZhciBkaXN0YW5jZUNvc3RNYXRyaXggPSBtYXRyaXguY3JlYXRlKHN0YXRlLm0gKyAxLCBzdGF0ZS5uICsgMSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcclxuICAgIGRpc3RhbmNlQ29zdE1hdHJpeFswXVswXSA9IDA7XHJcblxyXG4gICAgZm9yICh2YXIgcm93SW5kZXggPSAxOyByb3dJbmRleCA8PSBzdGF0ZS5tOyByb3dJbmRleCsrKSB7XHJcbiAgICAgICAgZm9yICh2YXIgY29sdW1uSW5kZXggPSBNYXRoLm1heCgxLCByb3dJbmRleCAtIHdpbmRvdyk7IGNvbHVtbkluZGV4IDw9IE1hdGgubWluKHN0YXRlLm4sIHJvd0luZGV4ICsgd2luZG93KTsgY29sdW1uSW5kZXgrKykge1xyXG4gICAgICAgICAgICB2YXIgY29zdCA9IHN0YXRlLmRpc3RhbmNlKHNbcm93SW5kZXggLSAxXSwgdFtjb2x1bW5JbmRleCAtIDFdKTtcclxuICAgICAgICAgICAgZGlzdGFuY2VDb3N0TWF0cml4W3Jvd0luZGV4XVtjb2x1bW5JbmRleF0gPVxyXG4gICAgICAgICAgICAgICAgY29zdCArIE1hdGgubWluKFxyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2VDb3N0TWF0cml4W3Jvd0luZGV4IC0gMV1bY29sdW1uSW5kZXhdLCAgICAgICAgICAvLyBJbnNlcnRpb25cclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlQ29zdE1hdHJpeFtyb3dJbmRleF1bY29sdW1uSW5kZXggLSAxXSwgICAgICAgICAgLy8gRGVsZXRpb25cclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlQ29zdE1hdHJpeFtyb3dJbmRleCAtIDFdW2NvbHVtbkluZGV4IC0gMV0pOyAgICAgLy8gTWF0Y2hcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGVuZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG4gICAgdmFyIHRpbWUgPSBlbmQgLSBzdGFydDtcclxuICAgIGRlYnVnKCc8IGNvbXB1dGVPcHRpbWFsUGF0aFdpdGhXaW5kb3cgKCcgKyB0aW1lICsgJyBtcyknKTtcclxuICAgIGRpc3RhbmNlQ29zdE1hdHJpeC5zaGlmdCgpO1xyXG4gICAgZGlzdGFuY2VDb3N0TWF0cml4ID0gZGlzdGFuY2VDb3N0TWF0cml4Lm1hcChmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgcmV0dXJuIHJvdy5zbGljZSgxLCByb3cubGVuZ3RoKTtcclxuICAgIH0pO1xyXG4gICAgc3RhdGUuZGlzdGFuY2VDb3N0TWF0cml4ID0gZGlzdGFuY2VDb3N0TWF0cml4O1xyXG4gICAgc3RhdGUuc2ltaWxhcml0eSA9IGRpc3RhbmNlQ29zdE1hdHJpeFtzdGF0ZS5tIC0gMV1bc3RhdGUubiAtIDFdO1xyXG4gICAgcmV0dXJuIHN0YXRlLnNpbWlsYXJpdHk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJldHJpZXZlT3B0aW1hbFBhdGgoc3RhdGUpIHtcclxuICAgIGRlYnVnKCc+IHJldHJpZXZlT3B0aW1hbFBhdGgnKTtcclxuICAgIHZhciBzdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cclxuICAgIHZhciByb3dJbmRleCA9IHN0YXRlLm0gLSAxO1xyXG4gICAgdmFyIGNvbHVtbkluZGV4ID0gc3RhdGUubiAtIDE7XHJcbiAgICB2YXIgcGF0aCA9IFtbcm93SW5kZXgsIGNvbHVtbkluZGV4XV07XHJcbiAgICB2YXIgZXBzaWxvbiA9IDFlLTE0O1xyXG4gICAgd2hpbGUgKChyb3dJbmRleCA+IDApIHx8IChjb2x1bW5JbmRleCA+IDApKSB7XHJcbiAgICAgICAgaWYgKChyb3dJbmRleCA+IDApICYmIChjb2x1bW5JbmRleCA+IDApKSB7XHJcbiAgICAgICAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihcclxuICAgICAgICAgICAgICAgIHN0YXRlLmRpc3RhbmNlQ29zdE1hdHJpeFtyb3dJbmRleCAtIDFdW2NvbHVtbkluZGV4XSwgICAgICAgICAgLy8gSW5zZXJ0aW9uXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0YW5jZUNvc3RNYXRyaXhbcm93SW5kZXhdW2NvbHVtbkluZGV4IC0gMV0sICAgICAgICAgIC8vIERlbGV0aW9uXHJcbiAgICAgICAgICAgICAgICBzdGF0ZS5kaXN0YW5jZUNvc3RNYXRyaXhbcm93SW5kZXggLSAxXVtjb2x1bW5JbmRleCAtIDFdKTsgICAgIC8vIE1hdGNoXHJcbiAgICAgICAgICAgIGlmIChjb21wYXJpc29uLm5lYXJseUVxdWFsKG1pbiwgc3RhdGUuZGlzdGFuY2VDb3N0TWF0cml4W3Jvd0luZGV4IC0gMV1bY29sdW1uSW5kZXggLSAxXSwgZXBzaWxvbikpIHtcclxuICAgICAgICAgICAgICAgIHJvd0luZGV4LS07XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleC0tO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb24ubmVhcmx5RXF1YWwobWluLCBzdGF0ZS5kaXN0YW5jZUNvc3RNYXRyaXhbcm93SW5kZXggLSAxXVtjb2x1bW5JbmRleF0sIGVwc2lsb24pKSB7XHJcbiAgICAgICAgICAgICAgICByb3dJbmRleC0tO1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmlzb24ubmVhcmx5RXF1YWwobWluLCBzdGF0ZS5kaXN0YW5jZUNvc3RNYXRyaXhbcm93SW5kZXhdW2NvbHVtbkluZGV4IC0gMV0sIGVwc2lsb24pKSB7XHJcbiAgICAgICAgICAgICAgICBjb2x1bW5JbmRleC0tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIGlmICgocm93SW5kZXggPiAwKSAmJiAoY29sdW1uSW5kZXggPT09IDApKSB7XHJcbiAgICAgICAgICAgIHJvd0luZGV4LS07XHJcbiAgICAgICAgfSBlbHNlIGlmICgocm93SW5kZXggPT09IDApICYmIChjb2x1bW5JbmRleCA+IDApKSB7XHJcbiAgICAgICAgICAgIGNvbHVtbkluZGV4LS07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBwYXRoLnB1c2goW3Jvd0luZGV4LCBjb2x1bW5JbmRleF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBlbmQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcclxuICAgIHZhciB0aW1lID0gZW5kIC0gc3RhcnQ7XHJcbiAgICBkZWJ1ZygnPCByZXRyaWV2ZU9wdGltYWxQYXRoICgnICsgdGltZSArICcgbXMpJyk7XHJcbiAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gRFRXO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kdHcvbGliL2R0dy5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lXG4gICAgICAgICAgICAgICAmJiAndW5kZWZpbmVkJyAhPSB0eXBlb2YgY2hyb21lLnN0b3JhZ2VcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcbiAgICAgICAgICAgICAgICAgIDogbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIHRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG4gIC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gZXhwb3J0cy5zdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKXtcbiAgdHJ5IHtcbiAgICByZXR1cm4gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2RlYnVnL2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L2RlYnVnL2RlYnVnLmpzXG4gKiogbW9kdWxlIGlkID0gNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSAnJyArIHN0cjtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDAwMCkgcmV0dXJuO1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vbXMvaW5kZXguanNcbiAqKiBtb2R1bGUgaWQgPSA1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJmdW5jdGlvbiB2YWxpZGF0ZVNlcXVlbmNlKHNlcXVlbmNlLCBzZXF1ZW5jZVBhcmFtZXRlck5hbWUpIHtcclxuICAgIGlmICghKHNlcXVlbmNlIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzZXF1ZW5jZSBcXCcnICsgc2VxdWVuY2VQYXJhbWV0ZXJOYW1lICsgJ1xcJyB0eXBlOiBleHBlY3RlZCBhbiBhcnJheScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZXF1ZW5jZS5sZW5ndGggPCAxKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBzZXF1ZW5jZSBkYXRhIHBvaW50cyBmb3IgXFwnJyArIHNlcXVlbmNlUGFyYW1ldGVyTmFtZSArICdcXCc6IGV4cGVjdGVkIGF0IGxlYXN0IG9uZScpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0eXBlb2Ygc2VxdWVuY2VbMF0gIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBkYXRhIHBvaW50cyB0eXBlcyBmb3Igc2VxdWVuY2UgXFwnJyArIHNlcXVlbmNlUGFyYW1ldGVyTmFtZSArICdcXCc6IGV4cGVjdGVkIGEgbnVtYmVyJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgc2VxdWVuY2U6IHZhbGlkYXRlU2VxdWVuY2VcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZHR3L2xpYi92YWxpZGF0ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciBjcmVhdGVBcnJheSA9IGZ1bmN0aW9uIChsZW5ndGgsIHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIGxlbmd0aCAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGxlbmd0aCB0eXBlJyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdmFsdWU6IGV4cGVjdGVkIGEgdmFsdWUgdG8gYmUgcHJvdmlkZWQnKTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgYXJyYXkgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcclxuICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn07XHJcblxyXG52YXIgY3JlYXRlTWF0cml4ID0gZnVuY3Rpb24gKG0sIG4sIHZhbHVlKSB7XHJcbiAgICB2YXIgbWF0cml4ID0gW107XHJcbiAgICBmb3IgKHZhciByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgbTsgcm93SW5kZXgrKykge1xyXG4gICAgICAgIG1hdHJpeC5wdXNoKGNyZWF0ZUFycmF5KG4sIHZhbHVlKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG1hdHJpeDtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY3JlYXRlOiBjcmVhdGVNYXRyaXhcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZHR3L2xpYi9tYXRyaXguanNcbiAqKiBtb2R1bGUgaWQgPSA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgRVBTSUxPTiA9IDIuMjIwNDQ2MDQ5MjUwMzEzMDgwODQ3MjYzMzM2MTgxNkUtMTY7XHJcblxyXG52YXIgbmVhcmx5RXF1YWwgPSBmdW5jdGlvbiAoaSwgaiwgZXBzaWxvbikge1xyXG4gICAgdmFyIGlBYnNvbHV0ZT0gTWF0aC5hYnMoaSk7XHJcbiAgICB2YXIgakFic29sdXRlID0gTWF0aC5hYnMoaik7XHJcbiAgICB2YXIgZGlmZmVyZW5jZSA9IE1hdGguYWJzKGkgLSBqKTtcclxuICAgIHZhciBlcXVhbCA9IGkgPT09IGo7XHJcbiAgICBpZiAoIWVxdWFsKSB7XHJcbiAgICAgICAgZXF1YWwgPSBkaWZmZXJlbmNlIDwgRVBTSUxPTjtcclxuICAgICAgICBpZiAoIWVxdWFsKSB7XHJcbiAgICAgICAgICAgIGVxdWFsID0gZGlmZmVyZW5jZSA8PSBNYXRoLm1heChpQWJzb2x1dGUsIGpBYnNvbHV0ZSkgKiBlcHNpbG9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZXF1YWw7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIEVQU0lMT046IEVQU0lMT04sXHJcbiAgICBuZWFybHlFcXVhbDogbmVhcmx5RXF1YWxcclxufTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kdHcvbGliL2NvbXBhcmlzb24uanNcbiAqKiBtb2R1bGUgaWQgPSA4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdmFyIGRpZmZlcmVuY2UgPSB4IC0geTtcclxuICAgIHZhciBtYW5oYXR0YW5EaXN0YW5jZSA9IE1hdGguYWJzKGRpZmZlcmVuY2UpO1xyXG4gICAgcmV0dXJuIG1hbmhhdHRhbkRpc3RhbmNlO1xyXG59O1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSB7XHJcbiAgICBkaXN0YW5jZTogZGlzdGFuY2VcclxufTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vZHR3L2xpYi9kaXN0YW5jZUZ1bmN0aW9ucy9tYW5oYXR0YW4uanNcbiAqKiBtb2R1bGUgaWQgPSA5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdmFyIGRpZmZlcmVuY2UgPSB4IC0geTtcclxuICAgIHZhciBldWNsaWRlYW5EaXN0YW5jZSA9IE1hdGguc3FydChkaWZmZXJlbmNlICogZGlmZmVyZW5jZSk7XHJcbiAgICByZXR1cm4gZXVjbGlkZWFuRGlzdGFuY2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGRpc3RhbmNlOiBkaXN0YW5jZVxyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kdHcvbGliL2Rpc3RhbmNlRnVuY3Rpb25zL2V1Y2xpZGVhbi5qc1xuICoqIG1vZHVsZSBpZCA9IDEwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJ2YXIgZGlzdGFuY2UgPSBmdW5jdGlvbiAoeCwgeSkge1xyXG4gICAgdmFyIGRpZmZlcmVuY2UgPSB4IC0geTtcclxuICAgIHZhciBzcXVhcmVkRXVjbGlkZWFuRGlzdGFuY2UgPSBkaWZmZXJlbmNlICogZGlmZmVyZW5jZTtcclxuICAgIHJldHVybiBzcXVhcmVkRXVjbGlkZWFuRGlzdGFuY2U7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICAgIGRpc3RhbmNlOiBkaXN0YW5jZVxyXG59O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9kdHcvbGliL2Rpc3RhbmNlRnVuY3Rpb25zL3NxdWFyZWRFdWNsaWRlYW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==